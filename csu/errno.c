
/*
 * msvcrt.dll errno functions
 *
 * Copyright 2000 Jon Griffiths
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

/*
dosmaperrno (msvcrt):
#define MIN_EACCES_RANGE ERROR_WRITE_PROTECT
#define ERROR_WRITE_PROTECT 19L
#define ERROR_BAD_UNIT 20L
#define ERROR_NOT_READY 21L
#define ERROR_BAD_COMMAND 22L
#define ERROR_CRC 23L
#define ERROR_BAD_LENGTH 24L
#define ERROR_SEEK 25L
#define ERROR_NOT_DOS_DISK 26L
#define ERROR_SECTOR_NOT_FOUND 27L
#define ERROR_OUT_OF_PAPER 28L
#define ERROR_WRITE_FAULT 29L
#define ERROR_READ_FAULT 30L
#define ERROR_GEN_FAILURE 31L
#define ERROR_SHARING_VIOLATION 32L
#define ERROR_LOCK_VIOLATION 33L
#define ERROR_WRONG_DISK 34L
#define ERROR_SHARING_BUFFER_EXCEEDED 36L
#define MAX_EACCES_RANGE ERROR_SHARING_BUFFER_EXCEEDED

#define MIN_EXEC_ERROR ERROR_INVALID_STARTING_CODESEG
#define ERROR_INVALID_STARTING_CODESEG 188L
#define ERROR_INVALID_STACKSEG 189L
#define ERROR_INVALID_MODULETYPE 190L
#define ERROR_INVALID_EXE_SIGNATURE 191L
#define ERROR_EXE_MARKED_INVALID 192L
#define ERROR_BAD_EXE_FORMAT 193L
#define ERROR_ITERATED_DATA_EXCEEDS_64k 194L
#define ERROR_INVALID_MINALLOCSIZE 195L
#define ERROR_DYNLINK_FROM_INVALID_RING 196L
#define ERROR_IOPL_NOT_ENABLED 197L
#define ERROR_INVALID_SEGDPL 198L
#define ERROR_AUTODATASEG_EXCEEDS_64k 199L
#define ERROR_RING2SEG_MUST_BE_MOVABLE 200L
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201L
#define ERROR_INFLOOP_IN_RELOC_CHAIN 202L
#define MAX_EXEC_ERROR ERROR_INFLOOP_IN_RELOC_CHAIN

*/

/* INTERNAL: Set the crt and dos errno's from the OS error given. */
int __get_errno(int oserr)
{
  int cerrno;
  switch(oserr)
  {
#define ERR_CASE(oserr) case oserr:
#define ERR_MAPS(oserr,crterr) case oserr:cerrno = crterr;break;
    ERR_CASE(ERROR_ACCESS_DENIED)
    ERR_CASE(ERROR_NETWORK_ACCESS_DENIED)
    ERR_CASE(ERROR_CANNOT_MAKE)
    ERR_CASE(ERROR_SEEK_ON_DEVICE)
    ERR_CASE(ERROR_LOCK_FAILED)
    ERR_CASE(ERROR_FAIL_I24)
    ERR_CASE(ERROR_CURRENT_DIRECTORY)
    ERR_CASE(ERROR_DRIVE_LOCKED)
    ERR_CASE(ERROR_NOT_LOCKED)
//    ERR_CASE(ERROR_INVALID_ACCESS)
    ERR_CASE(ERROR_WRITE_PROTECT)
    ERR_CASE(ERROR_BAD_UNIT)
//    ERR_CASE(ERROR_NOT_READY)
    ERR_CASE(ERROR_BAD_COMMAND)
    ERR_CASE(ERROR_CRC)
    ERR_CASE(ERROR_BAD_LENGTH)
    ERR_CASE(ERROR_SEEK)
    ERR_CASE(ERROR_NOT_DOS_DISK)
    ERR_CASE(ERROR_SECTOR_NOT_FOUND)
    ERR_CASE(ERROR_OUT_OF_PAPER)
    ERR_CASE(ERROR_WRITE_FAULT)
    ERR_CASE(ERROR_READ_FAULT)
    ERR_CASE(ERROR_GEN_FAILURE)
    ERR_CASE(ERROR_SHARING_VIOLATION)
    ERR_CASE(ERROR_LOCK_VIOLATION)
    ERR_CASE(ERROR_WRONG_DISK)
    ERR_MAPS(ERROR_SHARING_BUFFER_EXCEEDED,		EACCES);
    ERR_CASE(ERROR_FILE_NOT_FOUND)
    ERR_CASE(ERROR_NO_MORE_FILES)
    ERR_CASE(ERROR_BAD_PATHNAME)
    ERR_CASE(ERROR_BAD_NETPATH)
    ERR_CASE(ERROR_INVALID_DRIVE)
    ERR_CASE(ERROR_BAD_NET_NAME)
    ERR_CASE(ERROR_FILENAME_EXCED_RANGE)
    ERR_MAPS(ERROR_PATH_NOT_FOUND,       		ENOENT);
    ERR_MAPS(ERROR_IO_DEVICE,            		EIO);
    ERR_CASE(ERROR_INVALID_STARTING_CODESEG)
    ERR_CASE(ERROR_INVALID_STACKSEG)
    ERR_CASE(ERROR_INVALID_MODULETYPE)
    ERR_CASE(ERROR_INVALID_EXE_SIGNATURE)
    ERR_CASE(ERROR_EXE_MARKED_INVALID)
    ERR_CASE(ERROR_BAD_EXE_FORMAT)
    ERR_CASE(ERROR_ITERATED_DATA_EXCEEDS_64k)
    ERR_CASE(ERROR_INVALID_MINALLOCSIZE)
    ERR_CASE(ERROR_DYNLINK_FROM_INVALID_RING)
    ERR_CASE(ERROR_IOPL_NOT_ENABLED)
    ERR_CASE(ERROR_INVALID_SEGDPL)
    ERR_CASE(ERROR_AUTODATASEG_EXCEEDS_64k)
    ERR_CASE(ERROR_RING2SEG_MUST_BE_MOVABLE)
    ERR_CASE(ERROR_RELOC_CHAIN_XEEDS_SEGLIM)
    ERR_CASE(ERROR_INFLOOP_IN_RELOC_CHAIN)
    ERR_MAPS(ERROR_BAD_FORMAT,           		ENOEXEC);
    ERR_CASE(ERROR_INVALID_TARGET_HANDLE)
    ERR_CASE(ERROR_DIRECT_ACCESS_HANDLE)
    ERR_MAPS(ERROR_INVALID_HANDLE,       		EBADF);
    ERR_CASE(ERROR_OUTOFMEMORY)
    ERR_CASE(ERROR_NOT_ENOUGH_MEMORY)
    ERR_CASE(ERROR_INVALID_BLOCK)
    ERR_CASE(ERROR_NOT_ENOUGH_QUOTA)
    ERR_MAPS(ERROR_ARENA_TRASHED,        		ENOMEM);
	ERR_CASE(ERROR_NOT_READY)
	ERR_MAPS(ERROR_BUSY,                 		EBUSY);
    ERR_CASE(ERROR_ALREADY_EXISTS)
    ERR_MAPS(ERROR_FILE_EXISTS,          		EEXIST);
    ERR_MAPS(ERROR_BAD_DEVICE,           		ENODEV);
//    ERR_CASE(ERROR_NO_MORE_FILES)
    ERR_MAPS(ERROR_TOO_MANY_OPEN_FILES,  		EMFILE);
    ERR_MAPS(ERROR_DISK_FULL,            		ENOSPC);
    ERR_MAPS(ERROR_BROKEN_PIPE,          		EPIPE);
    ERR_MAPS(ERROR_POSSIBLE_DEADLOCK,    		EDEADLK);
    ERR_MAPS(ERROR_DIR_NOT_EMPTY,        		ENOTEMPTY);
    ERR_MAPS(ERROR_BAD_ENVIRONMENT,      		E2BIG);
    ERR_CASE(ERROR_WAIT_NO_CHILDREN)
    ERR_MAPS(ERROR_CHILD_NOT_COMPLETE,   		ECHILD);
    ERR_CASE(ERROR_NO_PROC_SLOTS)
    ERR_CASE(ERROR_MAX_THRDS_REACHED)
    ERR_MAPS(ERROR_NESTING_NOT_ALLOWED,  		EAGAIN);
	ERR_MAPS(ERROR_RETRY, 						EINTR);
	ERR_MAPS(ERROR_NOT_SAME_DEVICE, 			EXDEV);
//	ERR_CASE(ERROR_ARENA_TRASHED)
//	ERR_CASE(ERROR_BAD_COMMAND)
//	ERR_CASE(ERROR_BAD_ENVIRONMENT)
//	ERR_CASE(ERROR_BAD_FORMAT)
//	ERR_CASE(ERROR_GEN_FAILURE)
//	ERR_CASE(ERROR_INVALID_ACCESS)
//	ERR_CASE(ERROR_INVALID_BLOCK)
//	ERR_CASE(ERROR_INVALID_DATA)
//	ERR_CASE(ERROR_READ_FAULT)
//	ERR_MAPS(ERROR_WRITE_FAULT, 				EFAULT);
	ERR_CASE(ERROR_INVALID_ACCESS)
	ERR_CASE(ERROR_INVALID_DATA)
	ERR_CASE(ERROR_NEGATIVE_SEEK)
//	ERR_CASE(ERROR_INVALID_HANDLE)
	ERR_CASE(ERROR_INVALID_PARAMETER)
	ERR_CASE(ERROR_INVALID_FUNCTION)
  default:
    /*  Remaining cases map to EINVAL */
    /* FIXME: may be missing some errors above */
    cerrno = 									EINVAL;
  }
  return cerrno;
}

int werrno (void)
{
	return __get_errno(GetLastError());
}

#ifdef TEST

#define ERROR_MAX ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME 

LPSTR DecodeError(int ErrorCode)
{
     LPVOID lpMsgBuf;
     FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
          FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL, ErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
          (LPTSTR) &lpMsgBuf, 0, NULL);
    return lpMsgBuf;
}

int main (int argc, char **argv)
{
    LPVOID lpMsgBuf;
	int er;
	for (er=0; er <= ERROR_MAX; er++)	{
        if ((lpMsgBuf = DecodeError(er)) )
			fprintf(stderr, "%10d: %s %10d: %s\n",
				er, lpMsgBuf, __get_errno(er), strerror(__get_errno(er)));
	}
     LocalFree(lpMsgBuf);
	 return 0;
}
#endif
